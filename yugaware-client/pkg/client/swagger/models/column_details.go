// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ColumnDetails Details of a CQL database column
//
// swagger:model ColumnDetails
type ColumnDetails struct {

	// Relative position (column order) for this column, in the table and in CQL commands
	ColumnOrder int32 `json:"columnOrder,omitempty"`

	// True if this column is a clustering key
	IsClusteringKey bool `json:"isClusteringKey,omitempty"`

	// True if this column is a partition key
	IsPartitionKey bool `json:"isPartitionKey,omitempty"`

	// Column key type
	// Enum: [TINYINT SMALLINT INT BIGINT VARCHAR BOOLEAN FLOAT DOUBLE_PRECISION BLOB TIMESTAMP DECIMAL VARINT INET LIST MAP SET UUID TIMEUUID FROZEN DATE TIME JSONB USER_DEFINED_TYPE]
	KeyType string `json:"keyType,omitempty"`

	// Column name
	Name string `json:"name,omitempty"`

	// Sort order for this column. Valid only for clustering columns.
	// Enum: [NONE ASC DESC]
	SortOrder string `json:"sortOrder,omitempty"`

	// The column's data type
	// Enum: [TINYINT SMALLINT INT BIGINT VARCHAR BOOLEAN FLOAT DOUBLE_PRECISION BLOB TIMESTAMP DECIMAL VARINT INET LIST MAP SET UUID TIMEUUID FROZEN DATE TIME JSONB USER_DEFINED_TYPE]
	Type string `json:"type,omitempty"`

	// Column value name
	// Enum: [TINYINT SMALLINT INT BIGINT VARCHAR BOOLEAN FLOAT DOUBLE_PRECISION BLOB TIMESTAMP DECIMAL VARINT INET LIST MAP SET UUID TIMEUUID FROZEN DATE TIME JSONB USER_DEFINED_TYPE]
	ValueType string `json:"valueType,omitempty"`
}

// Validate validates this column details
func (m *ColumnDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateKeyType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortOrder(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var columnDetailsTypeKeyTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TINYINT","SMALLINT","INT","BIGINT","VARCHAR","BOOLEAN","FLOAT","DOUBLE_PRECISION","BLOB","TIMESTAMP","DECIMAL","VARINT","INET","LIST","MAP","SET","UUID","TIMEUUID","FROZEN","DATE","TIME","JSONB","USER_DEFINED_TYPE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		columnDetailsTypeKeyTypePropEnum = append(columnDetailsTypeKeyTypePropEnum, v)
	}
}

const (

	// ColumnDetailsKeyTypeTINYINT captures enum value "TINYINT"
	ColumnDetailsKeyTypeTINYINT string = "TINYINT"

	// ColumnDetailsKeyTypeSMALLINT captures enum value "SMALLINT"
	ColumnDetailsKeyTypeSMALLINT string = "SMALLINT"

	// ColumnDetailsKeyTypeINT captures enum value "INT"
	ColumnDetailsKeyTypeINT string = "INT"

	// ColumnDetailsKeyTypeBIGINT captures enum value "BIGINT"
	ColumnDetailsKeyTypeBIGINT string = "BIGINT"

	// ColumnDetailsKeyTypeVARCHAR captures enum value "VARCHAR"
	ColumnDetailsKeyTypeVARCHAR string = "VARCHAR"

	// ColumnDetailsKeyTypeBOOLEAN captures enum value "BOOLEAN"
	ColumnDetailsKeyTypeBOOLEAN string = "BOOLEAN"

	// ColumnDetailsKeyTypeFLOAT captures enum value "FLOAT"
	ColumnDetailsKeyTypeFLOAT string = "FLOAT"

	// ColumnDetailsKeyTypeDOUBLEPRECISION captures enum value "DOUBLE_PRECISION"
	ColumnDetailsKeyTypeDOUBLEPRECISION string = "DOUBLE_PRECISION"

	// ColumnDetailsKeyTypeBLOB captures enum value "BLOB"
	ColumnDetailsKeyTypeBLOB string = "BLOB"

	// ColumnDetailsKeyTypeTIMESTAMP captures enum value "TIMESTAMP"
	ColumnDetailsKeyTypeTIMESTAMP string = "TIMESTAMP"

	// ColumnDetailsKeyTypeDECIMAL captures enum value "DECIMAL"
	ColumnDetailsKeyTypeDECIMAL string = "DECIMAL"

	// ColumnDetailsKeyTypeVARINT captures enum value "VARINT"
	ColumnDetailsKeyTypeVARINT string = "VARINT"

	// ColumnDetailsKeyTypeINET captures enum value "INET"
	ColumnDetailsKeyTypeINET string = "INET"

	// ColumnDetailsKeyTypeLIST captures enum value "LIST"
	ColumnDetailsKeyTypeLIST string = "LIST"

	// ColumnDetailsKeyTypeMAP captures enum value "MAP"
	ColumnDetailsKeyTypeMAP string = "MAP"

	// ColumnDetailsKeyTypeSET captures enum value "SET"
	ColumnDetailsKeyTypeSET string = "SET"

	// ColumnDetailsKeyTypeUUID captures enum value "UUID"
	ColumnDetailsKeyTypeUUID string = "UUID"

	// ColumnDetailsKeyTypeTIMEUUID captures enum value "TIMEUUID"
	ColumnDetailsKeyTypeTIMEUUID string = "TIMEUUID"

	// ColumnDetailsKeyTypeFROZEN captures enum value "FROZEN"
	ColumnDetailsKeyTypeFROZEN string = "FROZEN"

	// ColumnDetailsKeyTypeDATE captures enum value "DATE"
	ColumnDetailsKeyTypeDATE string = "DATE"

	// ColumnDetailsKeyTypeTIME captures enum value "TIME"
	ColumnDetailsKeyTypeTIME string = "TIME"

	// ColumnDetailsKeyTypeJSONB captures enum value "JSONB"
	ColumnDetailsKeyTypeJSONB string = "JSONB"

	// ColumnDetailsKeyTypeUSERDEFINEDTYPE captures enum value "USER_DEFINED_TYPE"
	ColumnDetailsKeyTypeUSERDEFINEDTYPE string = "USER_DEFINED_TYPE"
)

// prop value enum
func (m *ColumnDetails) validateKeyTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, columnDetailsTypeKeyTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ColumnDetails) validateKeyType(formats strfmt.Registry) error {
	if swag.IsZero(m.KeyType) { // not required
		return nil
	}

	// value enum
	if err := m.validateKeyTypeEnum("keyType", "body", m.KeyType); err != nil {
		return err
	}

	return nil
}

var columnDetailsTypeSortOrderPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NONE","ASC","DESC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		columnDetailsTypeSortOrderPropEnum = append(columnDetailsTypeSortOrderPropEnum, v)
	}
}

const (

	// ColumnDetailsSortOrderNONE captures enum value "NONE"
	ColumnDetailsSortOrderNONE string = "NONE"

	// ColumnDetailsSortOrderASC captures enum value "ASC"
	ColumnDetailsSortOrderASC string = "ASC"

	// ColumnDetailsSortOrderDESC captures enum value "DESC"
	ColumnDetailsSortOrderDESC string = "DESC"
)

// prop value enum
func (m *ColumnDetails) validateSortOrderEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, columnDetailsTypeSortOrderPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ColumnDetails) validateSortOrder(formats strfmt.Registry) error {
	if swag.IsZero(m.SortOrder) { // not required
		return nil
	}

	// value enum
	if err := m.validateSortOrderEnum("sortOrder", "body", m.SortOrder); err != nil {
		return err
	}

	return nil
}

var columnDetailsTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TINYINT","SMALLINT","INT","BIGINT","VARCHAR","BOOLEAN","FLOAT","DOUBLE_PRECISION","BLOB","TIMESTAMP","DECIMAL","VARINT","INET","LIST","MAP","SET","UUID","TIMEUUID","FROZEN","DATE","TIME","JSONB","USER_DEFINED_TYPE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		columnDetailsTypeTypePropEnum = append(columnDetailsTypeTypePropEnum, v)
	}
}

const (

	// ColumnDetailsTypeTINYINT captures enum value "TINYINT"
	ColumnDetailsTypeTINYINT string = "TINYINT"

	// ColumnDetailsTypeSMALLINT captures enum value "SMALLINT"
	ColumnDetailsTypeSMALLINT string = "SMALLINT"

	// ColumnDetailsTypeINT captures enum value "INT"
	ColumnDetailsTypeINT string = "INT"

	// ColumnDetailsTypeBIGINT captures enum value "BIGINT"
	ColumnDetailsTypeBIGINT string = "BIGINT"

	// ColumnDetailsTypeVARCHAR captures enum value "VARCHAR"
	ColumnDetailsTypeVARCHAR string = "VARCHAR"

	// ColumnDetailsTypeBOOLEAN captures enum value "BOOLEAN"
	ColumnDetailsTypeBOOLEAN string = "BOOLEAN"

	// ColumnDetailsTypeFLOAT captures enum value "FLOAT"
	ColumnDetailsTypeFLOAT string = "FLOAT"

	// ColumnDetailsTypeDOUBLEPRECISION captures enum value "DOUBLE_PRECISION"
	ColumnDetailsTypeDOUBLEPRECISION string = "DOUBLE_PRECISION"

	// ColumnDetailsTypeBLOB captures enum value "BLOB"
	ColumnDetailsTypeBLOB string = "BLOB"

	// ColumnDetailsTypeTIMESTAMP captures enum value "TIMESTAMP"
	ColumnDetailsTypeTIMESTAMP string = "TIMESTAMP"

	// ColumnDetailsTypeDECIMAL captures enum value "DECIMAL"
	ColumnDetailsTypeDECIMAL string = "DECIMAL"

	// ColumnDetailsTypeVARINT captures enum value "VARINT"
	ColumnDetailsTypeVARINT string = "VARINT"

	// ColumnDetailsTypeINET captures enum value "INET"
	ColumnDetailsTypeINET string = "INET"

	// ColumnDetailsTypeLIST captures enum value "LIST"
	ColumnDetailsTypeLIST string = "LIST"

	// ColumnDetailsTypeMAP captures enum value "MAP"
	ColumnDetailsTypeMAP string = "MAP"

	// ColumnDetailsTypeSET captures enum value "SET"
	ColumnDetailsTypeSET string = "SET"

	// ColumnDetailsTypeUUID captures enum value "UUID"
	ColumnDetailsTypeUUID string = "UUID"

	// ColumnDetailsTypeTIMEUUID captures enum value "TIMEUUID"
	ColumnDetailsTypeTIMEUUID string = "TIMEUUID"

	// ColumnDetailsTypeFROZEN captures enum value "FROZEN"
	ColumnDetailsTypeFROZEN string = "FROZEN"

	// ColumnDetailsTypeDATE captures enum value "DATE"
	ColumnDetailsTypeDATE string = "DATE"

	// ColumnDetailsTypeTIME captures enum value "TIME"
	ColumnDetailsTypeTIME string = "TIME"

	// ColumnDetailsTypeJSONB captures enum value "JSONB"
	ColumnDetailsTypeJSONB string = "JSONB"

	// ColumnDetailsTypeUSERDEFINEDTYPE captures enum value "USER_DEFINED_TYPE"
	ColumnDetailsTypeUSERDEFINEDTYPE string = "USER_DEFINED_TYPE"
)

// prop value enum
func (m *ColumnDetails) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, columnDetailsTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ColumnDetails) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

var columnDetailsTypeValueTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TINYINT","SMALLINT","INT","BIGINT","VARCHAR","BOOLEAN","FLOAT","DOUBLE_PRECISION","BLOB","TIMESTAMP","DECIMAL","VARINT","INET","LIST","MAP","SET","UUID","TIMEUUID","FROZEN","DATE","TIME","JSONB","USER_DEFINED_TYPE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		columnDetailsTypeValueTypePropEnum = append(columnDetailsTypeValueTypePropEnum, v)
	}
}

const (

	// ColumnDetailsValueTypeTINYINT captures enum value "TINYINT"
	ColumnDetailsValueTypeTINYINT string = "TINYINT"

	// ColumnDetailsValueTypeSMALLINT captures enum value "SMALLINT"
	ColumnDetailsValueTypeSMALLINT string = "SMALLINT"

	// ColumnDetailsValueTypeINT captures enum value "INT"
	ColumnDetailsValueTypeINT string = "INT"

	// ColumnDetailsValueTypeBIGINT captures enum value "BIGINT"
	ColumnDetailsValueTypeBIGINT string = "BIGINT"

	// ColumnDetailsValueTypeVARCHAR captures enum value "VARCHAR"
	ColumnDetailsValueTypeVARCHAR string = "VARCHAR"

	// ColumnDetailsValueTypeBOOLEAN captures enum value "BOOLEAN"
	ColumnDetailsValueTypeBOOLEAN string = "BOOLEAN"

	// ColumnDetailsValueTypeFLOAT captures enum value "FLOAT"
	ColumnDetailsValueTypeFLOAT string = "FLOAT"

	// ColumnDetailsValueTypeDOUBLEPRECISION captures enum value "DOUBLE_PRECISION"
	ColumnDetailsValueTypeDOUBLEPRECISION string = "DOUBLE_PRECISION"

	// ColumnDetailsValueTypeBLOB captures enum value "BLOB"
	ColumnDetailsValueTypeBLOB string = "BLOB"

	// ColumnDetailsValueTypeTIMESTAMP captures enum value "TIMESTAMP"
	ColumnDetailsValueTypeTIMESTAMP string = "TIMESTAMP"

	// ColumnDetailsValueTypeDECIMAL captures enum value "DECIMAL"
	ColumnDetailsValueTypeDECIMAL string = "DECIMAL"

	// ColumnDetailsValueTypeVARINT captures enum value "VARINT"
	ColumnDetailsValueTypeVARINT string = "VARINT"

	// ColumnDetailsValueTypeINET captures enum value "INET"
	ColumnDetailsValueTypeINET string = "INET"

	// ColumnDetailsValueTypeLIST captures enum value "LIST"
	ColumnDetailsValueTypeLIST string = "LIST"

	// ColumnDetailsValueTypeMAP captures enum value "MAP"
	ColumnDetailsValueTypeMAP string = "MAP"

	// ColumnDetailsValueTypeSET captures enum value "SET"
	ColumnDetailsValueTypeSET string = "SET"

	// ColumnDetailsValueTypeUUID captures enum value "UUID"
	ColumnDetailsValueTypeUUID string = "UUID"

	// ColumnDetailsValueTypeTIMEUUID captures enum value "TIMEUUID"
	ColumnDetailsValueTypeTIMEUUID string = "TIMEUUID"

	// ColumnDetailsValueTypeFROZEN captures enum value "FROZEN"
	ColumnDetailsValueTypeFROZEN string = "FROZEN"

	// ColumnDetailsValueTypeDATE captures enum value "DATE"
	ColumnDetailsValueTypeDATE string = "DATE"

	// ColumnDetailsValueTypeTIME captures enum value "TIME"
	ColumnDetailsValueTypeTIME string = "TIME"

	// ColumnDetailsValueTypeJSONB captures enum value "JSONB"
	ColumnDetailsValueTypeJSONB string = "JSONB"

	// ColumnDetailsValueTypeUSERDEFINEDTYPE captures enum value "USER_DEFINED_TYPE"
	ColumnDetailsValueTypeUSERDEFINEDTYPE string = "USER_DEFINED_TYPE"
)

// prop value enum
func (m *ColumnDetails) validateValueTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, columnDetailsTypeValueTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ColumnDetails) validateValueType(formats strfmt.Registry) error {
	if swag.IsZero(m.ValueType) { // not required
		return nil
	}

	// value enum
	if err := m.validateValueTypeEnum("valueType", "body", m.ValueType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this column details based on context it is used
func (m *ColumnDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ColumnDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ColumnDetails) UnmarshalBinary(b []byte) error {
	var res ColumnDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
