// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Alert Alert definition. Used to send an alert notification.
//
// swagger:model Alert
type Alert struct {

	// Timestamp at which the alert was acknowledged
	// Read Only: true
	// Format: date-time
	AcknowledgedTime strfmt.DateTime `json:"acknowledgedTime,omitempty"`

	// Alert configuration type
	// Required: true
	// Read Only: true
	// Enum: [PLATFORM UNIVERSE]
	ConfigurationType string `json:"configurationType"`

	// Alert configuration UUID
	// Required: true
	// Read Only: true
	// Format: uuid
	ConfigurationUUID strfmt.UUID `json:"configurationUuid"`

	// Alert creation timestamp
	// Required: true
	// Read Only: true
	// Format: date-time
	CreateTime strfmt.DateTime `json:"createTime"`

	// Customer UUID
	// Required: true
	// Read Only: true
	// Format: uuid
	CustomerUUID strfmt.UUID `json:"customerUUID"`

	// Alert definition UUID
	// Required: true
	// Read Only: true
	// Format: uuid
	DefinitionUUID strfmt.UUID `json:"definitionUuid"`

	// labels
	// Required: true
	Labels []*AlertLabel `json:"labels"`

	// The alert's message text
	// Required: true
	// Read Only: true
	// Max Length: 2147483647
	// Min Length: 1
	Message string `json:"message"`

	// The alert's name
	// Required: true
	// Read Only: true
	// Max Length: 1000
	// Min Length: 1
	Name string `json:"name"`

	// Time of the next notification attempt
	// Read Only: true
	// Format: date-time
	NextNotificationTime strfmt.DateTime `json:"nextNotificationTime,omitempty"`

	// Time of the last notification attempt
	// Read Only: true
	// Format: date-time
	NotificationAttemptTime strfmt.DateTime `json:"notificationAttemptTime,omitempty"`

	// Count of failures to send a notification
	// Read Only: true
	NotificationsFailed int32 `json:"notificationsFailed,omitempty"`

	// Alert state in the last-sent notification
	// Read Only: true
	// Enum: [ACTIVE ACKNOWLEDGED SUSPENDED RESOLVED]
	NotifiedState string `json:"notifiedState,omitempty"`

	// Timestamp at which the alert was resolved
	// Read Only: true
	// Format: date-time
	ResolvedTime strfmt.DateTime `json:"resolvedTime,omitempty"`

	// Alert configuration severity
	// Required: true
	// Read Only: true
	// Enum: [SEVERE WARNING]
	Severity string `json:"severity"`

	// severity index
	// Required: true
	SeverityIndex *int32 `json:"severityIndex"`

	// The source of the alert
	// Required: true
	// Read Only: true
	SourceName string `json:"sourceName"`

	// The sourceUUID of the alert
	// Required: true
	// Read Only: true
	// Format: uuid
	SourceUUID strfmt.UUID `json:"sourceUUID"`

	// The alert's state
	// Required: true
	// Read Only: true
	// Enum: [ACTIVE ACKNOWLEDGED SUSPENDED RESOLVED]
	State string `json:"state"`

	// state index
	// Required: true
	StateIndex *int32 `json:"stateIndex"`

	// Alert UUID
	// Read Only: true
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`
}

// Validate validates this alert
func (m *Alert) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAcknowledgedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigurationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigurationUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefinitionUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMessage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNextNotificationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotificationAttemptTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotifiedState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResolvedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverityIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStateIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Alert) validateAcknowledgedTime(formats strfmt.Registry) error {
	if swag.IsZero(m.AcknowledgedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("acknowledgedTime", "body", "date-time", m.AcknowledgedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var alertTypeConfigurationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PLATFORM","UNIVERSE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeConfigurationTypePropEnum = append(alertTypeConfigurationTypePropEnum, v)
	}
}

const (

	// AlertConfigurationTypePLATFORM captures enum value "PLATFORM"
	AlertConfigurationTypePLATFORM string = "PLATFORM"

	// AlertConfigurationTypeUNIVERSE captures enum value "UNIVERSE"
	AlertConfigurationTypeUNIVERSE string = "UNIVERSE"
)

// prop value enum
func (m *Alert) validateConfigurationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeConfigurationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateConfigurationType(formats strfmt.Registry) error {

	if err := validate.RequiredString("configurationType", "body", m.ConfigurationType); err != nil {
		return err
	}

	// value enum
	if err := m.validateConfigurationTypeEnum("configurationType", "body", m.ConfigurationType); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateConfigurationUUID(formats strfmt.Registry) error {

	if err := validate.Required("configurationUuid", "body", strfmt.UUID(m.ConfigurationUUID)); err != nil {
		return err
	}

	if err := validate.FormatOf("configurationUuid", "body", "uuid", m.ConfigurationUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateCreateTime(formats strfmt.Registry) error {

	if err := validate.Required("createTime", "body", strfmt.DateTime(m.CreateTime)); err != nil {
		return err
	}

	if err := validate.FormatOf("createTime", "body", "date-time", m.CreateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateCustomerUUID(formats strfmt.Registry) error {

	if err := validate.Required("customerUUID", "body", strfmt.UUID(m.CustomerUUID)); err != nil {
		return err
	}

	if err := validate.FormatOf("customerUUID", "body", "uuid", m.CustomerUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateDefinitionUUID(formats strfmt.Registry) error {

	if err := validate.Required("definitionUuid", "body", strfmt.UUID(m.DefinitionUUID)); err != nil {
		return err
	}

	if err := validate.FormatOf("definitionUuid", "body", "uuid", m.DefinitionUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateLabels(formats strfmt.Registry) error {

	if err := validate.Required("labels", "body", m.Labels); err != nil {
		return err
	}

	for i := 0; i < len(m.Labels); i++ {
		if swag.IsZero(m.Labels[i]) { // not required
			continue
		}

		if m.Labels[i] != nil {
			if err := m.Labels[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("labels" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("labels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) validateMessage(formats strfmt.Registry) error {

	if err := validate.RequiredString("message", "body", m.Message); err != nil {
		return err
	}

	if err := validate.MinLength("message", "body", m.Message, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("message", "body", m.Message, 2147483647); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateName(formats strfmt.Registry) error {

	if err := validate.RequiredString("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", m.Name, 1000); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateNextNotificationTime(formats strfmt.Registry) error {
	if swag.IsZero(m.NextNotificationTime) { // not required
		return nil
	}

	if err := validate.FormatOf("nextNotificationTime", "body", "date-time", m.NextNotificationTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateNotificationAttemptTime(formats strfmt.Registry) error {
	if swag.IsZero(m.NotificationAttemptTime) { // not required
		return nil
	}

	if err := validate.FormatOf("notificationAttemptTime", "body", "date-time", m.NotificationAttemptTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var alertTypeNotifiedStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ACTIVE","ACKNOWLEDGED","SUSPENDED","RESOLVED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeNotifiedStatePropEnum = append(alertTypeNotifiedStatePropEnum, v)
	}
}

const (

	// AlertNotifiedStateACTIVE captures enum value "ACTIVE"
	AlertNotifiedStateACTIVE string = "ACTIVE"

	// AlertNotifiedStateACKNOWLEDGED captures enum value "ACKNOWLEDGED"
	AlertNotifiedStateACKNOWLEDGED string = "ACKNOWLEDGED"

	// AlertNotifiedStateSUSPENDED captures enum value "SUSPENDED"
	AlertNotifiedStateSUSPENDED string = "SUSPENDED"

	// AlertNotifiedStateRESOLVED captures enum value "RESOLVED"
	AlertNotifiedStateRESOLVED string = "RESOLVED"
)

// prop value enum
func (m *Alert) validateNotifiedStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeNotifiedStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateNotifiedState(formats strfmt.Registry) error {
	if swag.IsZero(m.NotifiedState) { // not required
		return nil
	}

	// value enum
	if err := m.validateNotifiedStateEnum("notifiedState", "body", m.NotifiedState); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateResolvedTime(formats strfmt.Registry) error {
	if swag.IsZero(m.ResolvedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("resolvedTime", "body", "date-time", m.ResolvedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var alertTypeSeverityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SEVERE","WARNING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeSeverityPropEnum = append(alertTypeSeverityPropEnum, v)
	}
}

const (

	// AlertSeveritySEVERE captures enum value "SEVERE"
	AlertSeveritySEVERE string = "SEVERE"

	// AlertSeverityWARNING captures enum value "WARNING"
	AlertSeverityWARNING string = "WARNING"
)

// prop value enum
func (m *Alert) validateSeverityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeSeverityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateSeverity(formats strfmt.Registry) error {

	if err := validate.RequiredString("severity", "body", m.Severity); err != nil {
		return err
	}

	// value enum
	if err := m.validateSeverityEnum("severity", "body", m.Severity); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateSeverityIndex(formats strfmt.Registry) error {

	if err := validate.Required("severityIndex", "body", m.SeverityIndex); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateSourceName(formats strfmt.Registry) error {

	if err := validate.RequiredString("sourceName", "body", m.SourceName); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateSourceUUID(formats strfmt.Registry) error {

	if err := validate.Required("sourceUUID", "body", strfmt.UUID(m.SourceUUID)); err != nil {
		return err
	}

	if err := validate.FormatOf("sourceUUID", "body", "uuid", m.SourceUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

var alertTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ACTIVE","ACKNOWLEDGED","SUSPENDED","RESOLVED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeStatePropEnum = append(alertTypeStatePropEnum, v)
	}
}

const (

	// AlertStateACTIVE captures enum value "ACTIVE"
	AlertStateACTIVE string = "ACTIVE"

	// AlertStateACKNOWLEDGED captures enum value "ACKNOWLEDGED"
	AlertStateACKNOWLEDGED string = "ACKNOWLEDGED"

	// AlertStateSUSPENDED captures enum value "SUSPENDED"
	AlertStateSUSPENDED string = "SUSPENDED"

	// AlertStateRESOLVED captures enum value "RESOLVED"
	AlertStateRESOLVED string = "RESOLVED"
)

// prop value enum
func (m *Alert) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateState(formats strfmt.Registry) error {

	if err := validate.RequiredString("state", "body", m.State); err != nil {
		return err
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateStateIndex(formats strfmt.Registry) error {

	if err := validate.Required("stateIndex", "body", m.StateIndex); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this alert based on the context it is used
func (m *Alert) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAcknowledgedTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigurationType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigurationUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreateTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomerUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefinitionUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLabels(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNextNotificationTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNotificationAttemptTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNotificationsFailed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNotifiedState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResolvedTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSeverity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Alert) contextValidateAcknowledgedTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "acknowledgedTime", "body", strfmt.DateTime(m.AcknowledgedTime)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateConfigurationType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "configurationType", "body", string(m.ConfigurationType)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateConfigurationUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "configurationUuid", "body", strfmt.UUID(m.ConfigurationUUID)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateCreateTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createTime", "body", strfmt.DateTime(m.CreateTime)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateCustomerUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "customerUUID", "body", strfmt.UUID(m.CustomerUUID)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateDefinitionUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "definitionUuid", "body", strfmt.UUID(m.DefinitionUUID)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateLabels(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Labels); i++ {

		if m.Labels[i] != nil {
			if err := m.Labels[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("labels" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("labels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateNextNotificationTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "nextNotificationTime", "body", strfmt.DateTime(m.NextNotificationTime)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateNotificationAttemptTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "notificationAttemptTime", "body", strfmt.DateTime(m.NotificationAttemptTime)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateNotificationsFailed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "notificationsFailed", "body", int32(m.NotificationsFailed)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateNotifiedState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "notifiedState", "body", string(m.NotifiedState)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateResolvedTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "resolvedTime", "body", strfmt.DateTime(m.ResolvedTime)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateSeverity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "severity", "body", string(m.Severity)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateSourceName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sourceName", "body", string(m.SourceName)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateSourceUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sourceUUID", "body", strfmt.UUID(m.SourceUUID)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", strfmt.UUID(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Alert) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Alert) UnmarshalBinary(b []byte) error {
	var res Alert
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
