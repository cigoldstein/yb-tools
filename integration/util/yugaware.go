package util

import (
	"bytes"
	"context"
	"fmt"
	"strconv"

	"github.com/go-logr/logr"
	. "github.com/icza/gox/gox"
	. "github.com/onsi/gomega"
	"github.com/yugabyte/yb-tools/yugatool/api/yb/common"
	"github.com/yugabyte/yb-tools/yugaware-client/cmd"
	"github.com/yugabyte/yb-tools/yugaware-client/pkg/client"
	"github.com/yugabyte/yb-tools/yugaware-client/pkg/client/swagger/client/session_management"
	"github.com/yugabyte/yb-tools/yugaware-client/pkg/client/swagger/models"
)

type YWContext struct {
	*client.YugawareClient

	Hostname             string
	DialTimeout          int
	SkipHostVerification bool
	CACert               string
	ClientCert           string
	ClientKey            string
	APIToken             string
}

func NewYugawareContext(ctx context.Context, logger logr.Logger, hostname string, dialTimeout int, skipHostVerification bool, cacert, clientCert, clientKey, apiToken string) *YWContext {
	ywclient, err := client.New(ctx, logger, hostname).
		TLSOptions(&client.TLSOptions{
			SkipHostVerification: skipHostVerification,
			CaCertPath:           cacert,
			CertPath:             clientCert,
			KeyPath:              clientKey,
		}).APIToken(apiToken).
		TimeoutSeconds(dialTimeout).
		Connect()
	Expect(err).NotTo(HaveOccurred())

	return &YWContext{
		YugawareClient:       ywclient,
		Hostname:             hostname,
		DialTimeout:          dialTimeout,
		SkipHostVerification: skipHostVerification,
		CACert:               cacert,
		ClientCert:           clientCert,
		ClientKey:            clientKey,
		APIToken:             apiToken,
	}
}

func (c *YWContext) CreateUniverseIfNotExists(universeName, provider, instanceType string, withTLS bool, regions ...string) *models.UniverseResp {
	universe := c.GetUniverse(universeName)
	if universe == nil {
		opts := []string{"universe", "create", universeName, "--provider", provider, "--instance-type", instanceType, "--wait"}
		for _, region := range regions {
			opts = append(opts, "--regions", region)
		}

		if withTLS {
			opts = append(opts, "--enable-encryption")
		}

		_, err := c.RunYugawareCommand(opts...)
		Expect(err).NotTo(HaveOccurred())

		universe = c.GetUniverse(universeName)
	}
	Expect(universe).NotTo(BeNil())
	return universe
}

func (c *YWContext) CleanupUniverse(universeName string) {
	universe := c.GetUniverse(universeName)
	if universe != nil {
		_, err := c.RunYugawareCommand("universe", "delete", universeName, "--wait", "--approve", "--delete-backups", "--force")

		Expect(err).NotTo(HaveOccurred())
	}
}

func (c *YWContext) GetUniverse(universeName string) *models.UniverseResp {
	universe, err := c.GetUniverseByIdentifier(universeName)
	Expect(err).NotTo(HaveOccurred())
	return universe
}

func (c *YWContext) RunYugawareCommand(args ...string) ([]byte, error) {
	ywCommand := cmd.RootInit()
	args = append(args, "--hostname", c.Hostname, "--dialtimeout", strconv.Itoa(c.DialTimeout), "--api-token", c.APIToken)

	if c.SkipHostVerification {
		args = append(args, "--skiphostverification")
	}

	if c.CACert != "" {
		args = append(args, "--cacert", c.CACert)
	}

	if c.ClientCert != "" {
		args = append(args, "--client-cert", c.ClientCert)
	}

	if c.ClientKey != "" {
		args = append(args, "--client-key", c.ClientKey)
	}

	buf := new(bytes.Buffer)
	ywCommand.SetOut(buf)
	ywCommand.SetErr(buf)

	ywCommand.SetArgs(args)

	err := ywCommand.Execute()
	return buf.Bytes(), err
}

func (c *YWContext) GetMasterAddresses(universeName string) []*common.HostPortPB {
	universe := c.GetUniverse(universeName)

	var masters []*common.HostPortPB
	for _, node := range universe.UniverseDetails.NodeDetailsSet {
		if node.IsMaster {
			masters = append(masters, &common.HostPortPB{Host: &node.CloudInfo.PrivateIP, Port: NewUint32(uint32(node.MasterRPCPort))})
		}
	}

	return masters
}

func (c *YWContext) CreateYugatoolContext(universeName string) *YugatoolContext {
	universe := c.GetUniverse(universeName)

	Expect(len(universe.UniverseDetails.Clusters)).To(BeNumerically(">", 0))
	userIntent := universe.UniverseDetails.Clusters[0].UserIntent

	useEncryption := userIntent.EnableNodeToNodeEncrypt

	skipHostVerification := false

	var cacert []byte
	var err error
	if useEncryption {
		// TODO: Work around for PLAT-3408 - the certificate generated by platform for kubernetes is not valid
		if userIntent.ProviderType == "kubernetes" {
			skipHostVerification = true
		}

		cacert, err = c.RunYugawareCommand("certificate", "get-root", universe.UniverseDetails.RootCA.String())
		Expect(err).NotTo(HaveOccurred())
		Expect(len(cacert)).To(BeNumerically(">", 0))
	}

	// TODO: Should test with the clientCert or clientKey
	return NewYugatoolContext(c.Log, c.GetMasterAddresses(universeName), int64(c.DialTimeout), cacert, nil, nil, skipHostVerification)
}

func (c *YWContext) DumpYugawareLogs() {
	params := session_management.NewGetLogsParams().
		WithMaxLines(int32(1200))

	response, err := c.PlatformAPIs.SessionManagement.GetLogs(params, c.SwaggerAuth)
	if err == nil {
		logLines := response.GetPayload().Lines

		fmt.Println("===============================================================")
		fmt.Println("                       Yugaware Logs")
		fmt.Println("===============================================================")
		fmt.Println()

		for _, line := range logLines {
			fmt.Println(line)
		}

		fmt.Println()
	}
}
